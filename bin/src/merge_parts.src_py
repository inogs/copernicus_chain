#!/usr/bin/env python

import os
import glob
import re
import optparse
import sys
import md5

def expand_keys(s, keydict):
  re_tpl_str = r"\$\([^\)]+\)"
  re_tpl = re.compile(re_tpl_str)
  while True:
    re_match = re_tpl.search(s)
    if re_match is None:
      break
    begin, end = re_match.span()
    key = s[begin:end]
    if key in keydict:
      #print "<<< [%s] <%s>" % (key, s)
      s = s[:begin] + keydict[key] + s[end:]
      #print ">>> [%s] <%s>" % (key, s)
    else:
      sys.stderr.write("ERR: invalid key %s\n" % key)
      sys.exit(1)
  return s

class Stream(object):
  def __init__(self, stream=None):
    if stream is None:
      stream = sys.stdout
    self._stream = stream
    self._last_line = None

  def clean(self):
    if self._last_line:
      self._stream.write("\r%s\r" % (' '*len(self._last_line)))
      self._stream.flush()
      self._last_line = None
  
  def write(self, line):
    self.clean()
    self._stream.write(line)
    self._stream.flush()
    self._last_line = line

  def finish(self):
    self._stream.write("\n")
    self._stream.flush()
    self._last_line = None

def main():

  
  opt_list = [
		optparse.make_option(   '-o', '--output-filename',
					dest='output_filenames',
					type="string",
					action="append",
					default=[],
					help='add output_filename [default: %default]',
		),
		optparse.make_option(   '-i', '--input-filename',
					dest='input_filename',
					type="string",
					default="$(output_dirname)/parts/$(output_basename)_part$(partid)",
					help='input_filename [default: %default]',
		),
		optparse.make_option(   '-p', '--partid-re',
					dest='partid_re',
					type="string",
					default=r"\d+",
					help='input_filename [default: %default]',
		),
		optparse.make_option(   '-b', '--block-size',
					dest='block_size',
					type="int",
					default=100*1024*1024,
					help='block size [default: %default]',
		),
		optparse.make_option(   '-d', '--dir',
					dest='dir',
					type="string",
					default=None,
					help='load parts from dir [default: %default]',
		),
  ]

  help_formatter=optparse.IndentedHelpFormatter(max_help_position=38)
  parser = optparse.OptionParser(option_list=opt_list,formatter=help_formatter)
  (options,args) = parser.parse_args(sys.argv[1:])

  key_output_basename = '$(output_basename)'
  key_output_dirname = '$(output_dirname)'
  key_partid = '$(partid)'
  partid_res = r"(?P<partid>%s)" % options.partid_re


  input_filename_pattern = options.input_filename

  if not options.output_filenames:
    if args:
      options.output_filenames = args.pop(0)

  if options.dir:
    if options.output_filenames:
      sys.stderr.write("ERR: -d|--dir and -o|--output-filename are mutually exclusive options\n")
      sys.exit(1)
    keydict_res = {
		key_output_basename	: r'(?P<output_basename>.*)',
		key_output_dirname	: options.dir,
		key_partid		: partid_res,
    }
    keydict_glob = keydict_res.copy()
    keydict_glob[key_partid] = '*'
    keydict_glob[key_output_basename] = '*'
    parts_filename_pattern = expand_keys(input_filename_pattern, keydict_glob)
    parts_filename_res = expand_keys(input_filename_pattern, keydict_res)
    parts_filename_re = re.compile(parts_filename_res)
    output_basenames = []
    for parts_filename in glob.glob(parts_filename_pattern):
      re_match = parts_filename_re.match(parts_filename)
      if re_match and 'output_basename' in re_match.groupdict():
        output_basename = re_match.groupdict()['output_basename']
        #print parts_filename, output_basename
        if not output_basename in output_basenames:
          output_basenames.append(output_basename)
    if not output_basenames:
      sys.stderr.write("WARNING: no parts in %s\n" % options.dir)
      sys.exit(0)
    options.output_filenames = [os.path.join(options.dir, output_basename) for output_basename in output_basenames]
        
  if not options.output_filenames:
    sys.stderr.write("ERR: missing mandatory option -o|--output-filename or -d|--dir\n")
    sys.exit(1)

  for output_filename in options.output_filenames:
    output_filename = os.path.abspath(output_filename)
    md5_filename = "%s.md5" % output_filename
    if os.path.exists(output_filename):
      try:
        output_file = open(output_filename, 'rb')
        md5_obj = md5.md5()
        while True:
          block = output_file.read(options.block_size)
          if not block:
            break
          md5_obj.update(block)
        output_md5 = md5_obj.hexdigest()
      finally:
        output_file.close()
    else:
      output_md5 = None
    if os.path.exists(md5_filename):
      try:
        md5_file = open(md5_filename, 'rb')
        ref_md5 = md5_file.read()
      finally:
        md5_file.close()
    else:
      ref_md5 = None
    if output_md5 is not None and output_md5 == ref_md5:
      sys.stderr.write("...output file %s already exists and md5 checksum matches\n" % output_filename)
      continue
    keydict_res = {
			key_output_basename	: os.path.basename(output_filename),
			key_output_dirname	: os.path.dirname(output_filename),
			key_partid		: r"(?P<partid>%s)" % options.partid_re,
    }
    keydict_glob = keydict_res.copy()
    keydict_glob[key_partid] = '*'
  
    input_filename_res = expand_keys(input_filename_pattern, keydict_res)
    input_filename_glob = expand_keys(input_filename_pattern, keydict_glob)
  
    #print input_filename_res
    #print input_filename_glob
    input_filename_re = re.compile(input_filename_res)

    input_filename_dict = {}
    for input_filename in glob.glob(input_filename_glob):
      re_match = input_filename_re.match(input_filename)
      if re_match:
        partid = int(re_match.groupdict()['partid'])
        input_filename_dict[partid] = input_filename
    
    input_filename_lst = input_filename_dict.items()
    input_filename_lst.sort(lambda x, y: cmp(x[0], y[0]))
    input_filenames = [e[1] for e in input_filename_lst]
  
    stream = Stream()
  
    output_basename = os.path.basename(output_filename)
    fmt = "%(input_basename)s[%(begin)d:%(end)d] [%(block_len)d] -> %(output_basename)s[%(output_size)d]"
    md5_obj = md5.md5()
    try:
      output_file = open(output_filename, 'wb')
      output_size = 0
      for input_filename in input_filenames:
        input_basename = os.path.basename(input_filename)
        try:
          input_file = open(input_filename, 'rb')
          
          begin = 0
          while True:
            block = input_file.read(options.block_size)
            block_len = len(block)
            output_size += block_len
            if block_len == 0:
              break
            md5_obj.update(block)
            output_file.write(block)
            dd = {
			'input_filename':	input_filename,
			'output_filename':	output_filename,
			'input_basename':	input_basename,
			'output_basename':	output_basename,
			'begin':		begin,
			'end':			begin+block_len,
			'block_len':		block_len,
			'output_size':		output_size,
			'block_size':		options.block_size,
            }
            stream.write(fmt % dd)
            begin += len(block)
          stream.finish()
        except IOError, e:
          sys.stderr.write("cannot open input file %s: %s: %s\n" % (input_filename, e.__class__.__name__, e))
          sys.exit(1)
        input_file.close()
    except IOError, e:
      sys.stderr.write("cannot open output file %s: %s: %s\n" % (output_filename, e.__class__.__name__, e))
      sys.exit(1)
    output_file.close()
    if not os.path.exists(md5_filename):
      try:
        md5_file = open(md5_filename, "wb")
        md5_file.write(md5_obj.hexdigest())
      finally:
        md5_file.close()
    elif ref_md5 is not None and ref_md5 != md5_obj.hexdigest():
      sys.stderr.write("ERR: md5 checksum does not match: %s != %s\n" % (ref_md5, md5_obj.hexdigest()))

if __name__ == "__main__":
  main()
