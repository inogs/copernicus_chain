#!/bin/ksh
# This script downloads, decompresses and eventually checks
# the input files.
# Input files are located at CMCC ftp server; data are
# downloaded using http with the config file
# $OPA_ETCDIR/http-config/.cmcc.httpconfig
# 

# Load common profile
. @@(I:OPA_HOME)/bin/opa_profile.inc

_FORCE_DOWNLOAD=${OPA_FORCE_DOWNLOAD}		# If true, downloads remote files even if they are already on local filesystem

function print_help {
  cat <<EofCat
Usage: $OPA_PROGNAME [options]
[options]
$(opa_set_default_run__print_options)
	--help|-h			show this help
	--force-download		do not try to resume download
					["$_FORCE_DOWNLOAD"]
	--try-resume			try to resume download
					["! $_FORCE_DOWNLOAD"]
	--dry-run			show only required files
					["$_DRY_RUN"]
	--enable-abort-on-errors|-a	abort download in case of errors (missing files)	
					["$_ABORT_ON_ERRORS"]
	--disable-abort-on-errors|-A	continue download of remaining files in case of errors
					["! $_ABORT_ON_ERRORS"]
	--enable-input-timeout|-z	enable timeout on input data
					["$_INPUT_TIMEOUT_ENABLED"]
	--disable-input-timeout|-Z	disable timeout on input data
					["! $_INPUT_TIMEOUT_ENABLED"]
	--without-timeout		disable timeout and abort on errors
	--with-timeout			dummy option: enable timeout and abort on errors as default
	--delay|-d			delay in seconds after dowlonad errors
					["$_DELAY"]
	--max-tries|-m			max number of tries
					["$_MAX_TRIES"]
	--disable-download		disable download from remote site;
					useful for recovery
					["$_DISABLE_DOWNLOAD"]
	--recovery			actually => --disable-download
					["$_RECOVERY"]
        --emerg|-e                      emergency run: use the backup repository to download files

EofCat
}

opa_set_default_run_options=' '
_ABORT_ON_ERRORS=true
_DRY_RUN=false
_EMERG=false
_INPUT_TIMEOUT_ENABLED="$OPA_INPUT_TIMEOUT_ENABLED"
_DELAY=5
_MAX_TRIES=$OPA_INPUT_TIMEOUT_COUNT_MAX
_DISABLE_DOWNLOAD="$OPA_UNDEFINED"
_RECOVERY="$OPA_UNDEFINED"
while [[ ${#@} -ne 0 ]] ; do
  arg="$1"
  shift 1
  case "$arg" in
    --help|-h)
      print_help
      exit 0
      ;;
    --rundate|-r|--weekday|-w|--today|-t|--submit-day-offset|-s)
      opa_set_default_run_options="${opa_set_default_run_options}$arg '$1' "
      shift 1
      ;;
    --dry-run)
      _DRY_RUN=true
      ;;
    --force-download)
      _FORCE_DOWNLOAD=true
      ;;
    --try-resume)
      _FORCE_DOWNLOAD=false
      ;;
    --enable-abort-on-errors|-a)
      _ABORT_ON_ERRORS=true
      ;;
    --disable-abort-on-errors|-A)
      _ABORT_ON_ERRORS=false
      ;;
    --enable-input-timeout|-z)
      _INPUT_TIMEOUT_ENABLED=true
      ;;
    --disable-input-timeout|-Z)
      _INPUT_TIMEOUT_ENABLED=false
      ;;
    --without-timeout)
      _ABORT_ON_ERRORS=false
      _INPUT_TIMEOUT_ENABLED=false
      ;;
    --with-timeout)
      ;;
    --delay|-d)
      _DELAY="$1"
      shift 1
      ;;
    --max-tries|-m)
      _MAX_TRIES="$1"
      shift 1
      ;;
    --disable-download)
      _DISABLE_DOWNLOAD=true
      ;;
    --recovery)
      _RECOVERY=true
      ;;
    --emerg|-e)
      _EMERG=true
      ;;
    *)
      echo "ERROR: wrong command line option <$arg>" 1>&2
      exit 2
      ;;
  esac
done

# Rundate definition
opa_prex "opa_set_default_run $opa_set_default_run_options"
opa_prex "opa_set_run $OPA_DEFAULT_RUNTYPE $OPA_DEFAULT_RUNDATE"

# Default
if [[ "$_RECOVERY" == "$OPA_UNDEFINED" ]] ; then
  _RECOVERY="$OPA_RECOVERY_MODE"
fi
if [[ "$_DISABLE_DOWNLOAD" == "$OPA_UNDEFINED" ]] ; then
  _DISABLE_DOWNLOAD="$_RECOVERY"
fi

cat <<EOFCAT
RECOVERY:		$_RECOVERY
DISABLE_DOWNLOAD:	$_DISABLE_DOWNLOAD
EOFCAT

# start
opa_start
case $OPA_RUNTYPE in
   'analysis' )
   # Get the name of OPAOPER_A wind input files
   opa_set_input_files__opaoper_a
   opa_print_input_files__opaoper_a
      ;;
  'forecast' )
    # Get the name of OPAOPER_F data input files
    opa_set_input_files__opaoper_f
    opa_print_input_files__opaoper_f
    ;;
  * ) opa_die 10 "Unsupporte runtype: $OPA_RUNTYPE"
    ;;
esac


if [[ -f $OPA_ACTUAL_INPUT_DESCRIPTION_FILE ]] ; then
  . $OPA_ACTUAL_INPUT_DESCRIPTION_FILE
fi


function opa_check_input_file {
  # This function checks if the input file is correct
  # input file name is: yymmdd_variable.nc

  #typeset _input_file="$1"
  #typeset _date=$( echo "$_input_file" | cut -c1-6 )			# yymmdd
  #typeset _var=$( echo "$_input_file" | cut -d_ -f2 | cut -d. -f1 ) 	# Variable name

  opa_prex "$OPA_BINDIR/ncdump -h $1 > /dev/null"
  return $?
}

function opa_copy_attributes {
  typeset _source="$1"
  typeset _target="$2"
  # time:
  $OPA_BINDIR/touch -t $($OPA_BINDIR/date --date="1970-01-01 $($OPA_BINDIR/stat -c %Z "$_source") sec UTC" +'%Y%m%d%H%M.%S')    "$_target"
  $OPA_BINDIR/touch -t $($OPA_BINDIR/date --date="1970-01-01 $($OPA_BINDIR/stat -c %X "$_source") sec UTC" +'%Y%m%d%H%M.%S') -a "$_target"
  $OPA_BINDIR/touch -t $($OPA_BINDIR/date --date="1970-01-01 $($OPA_BINDIR/stat -c %Y "$_source") sec UTC" +'%Y%m%d%H%M.%S') -m "$_target"
  # permissions:
  $OPA_BINDIR/chmod $($OPA_BINDIR/stat -c %a "$_source") "$_target"
}

function opa_decompress {
  typeset   _compress_mode="$1"
  typeset   _compressed_file="$2"
  typeset   _decompressed_file="$3"
  typeset -i _ec
  case "$_compress_mode" in
    gzip)
      opa_prex "gzip -dc '$_compressed_file' > '$_decompressed_file'" ; _ec=$?
      if [[ $_ec -eq 2 ]] ; then
        opa_log 1 "WARNING: command <gzip -dc '$_compressed_file' > '$_decompressed_file'> raised a warning! - warnings are ignored"
        _ec=0
      fi
      opa_copy_attributes "$_compressed_file" "$_decompressed_file"
      ;;
    bzip2)
      opa_prex "bzip2 -dc '$_compressed_file' > '$_decompressed_file'" ; _ec=$?
      opa_copy_attributes "$_compressed_file" "$_decompressed_file"
      ;;
    none)
      opa_copy_attributes "$_compressed_file" "$_decompressed_file"
#       opa_prex "cp -p '$_compressed_file' '$_decompressed_file'" ; _ec=$?
      ;;
    *)
      echo "INTERNAL ERROR: compress mode ${_compress_mode}" 1>&2
      exit 1
      ;;
  esac
  return $_ec
}

function opa_download {
  typeset    _download_mode="$1"
  typeset    _download_protocol=$(echo "$_download_mode" | cut -d: -f1)
  typeset    _download_config=$(echo "$_download_mode" | cut -d: -f2-)
  typeset    _ldir="$2"
  typeset    _rfile="$3"
  typeset -i _ec
  case "$_download_protocol" in
    ncftp)
      opa_prex "$OPA_BINDIR/ncftpget -f $_download_config '$_ldir' '$_rfile'" ; _ec=$?
      ;;
    http)
      typeset _keyword
      typeset _value
      typeset _host
      typeset _user
      typeset _pass
      while read _keyword _value ; do
        case "$_keyword" in
          host)
            _host="$_value"
            ;;
          user)
            _user="$_value"
            ;;
          pass)
            _pass="$_value"
            ;;
          *)
            echo "INTERNAL ERROR: invalid key '${_keyword}'='${_value}'" 1>&2
            ;;
        esac
      done < "$_download_config"
      typeset _lfile="$_ldir/$(basename $_rfile)"
      opa_prex "wget --continue --waitretry='3' --tries='10' --progress='dot:mega' --ftp-user='$_user' --ftp-password='$_pass' --output-document='$_lfile' '$_host:$_rfile'" ; _ec=$?
      ;;
    *)
      echo "INTERNAL ERROR: invalid protocol ${_download_protocol}" 1>&2
      exit 1
      ;;
  esac
  return $_ec

}

set -A MISSING_FILES --
typeset -i MISSING_FILES_NUM=0

function opa_add_missing_files {
  typeset _file
  for _file in "$@" ; do
    MISSING_FILES[MISSING_FILES_NUM]="$_file"
    MISSING_FILES_NUM=$(( $MISSING_FILES_NUM + 1 ))
  done
}

function opa_print_missing_files {
  if [[ $MISSING_FILES_NUM -gt 0 ]] ; then
    typeset _message
    opa_log 1 "WARNING: $MISSING_FILES_NUM missing files:"
    opa_log 2 "================================================================================"
    typeset -i _index=0
    while [[ $_index -lt $MISSING_FILES_NUM ]] ; do
      _message=$(printf "%3d) %s\n" "$_index" "${MISSING_FILES[_index]}")
      opa_log 2 "$_message"
      _index=$(( $_index + 1 ))
    done
    opa_log 2 "================================================================================"
  else
    opa_log 1 "All files successfully downloaded!"
  fi
}

function opa_set_difference {
  typeset _a="$1"
  typeset _b="$2"
  typeset _item
  typeset _d=" "
  for _item in $_a ; do
    if [[ $(echo " $_b " | grep -c " $_item ") -eq 0 ]] ; then
      _d="$_d$_item "
    fi
  done
  echo "$_d"
}


_DOWNLOADED_INDICES_A=" "
_DOWNLOADED_INDICES_F=" "
_DOWNLOADED_INDICES_D=" "

function opa_get_files {
  # Download input files $3... from remote directory $1 to local directory $2
  # If files are not found on remote server, or checks fails on downloaded files,
  # the function tries again to download the file, until the $OPA_INPUT_TIMEOUT__UTC
  # time is reached
  # For each input file, a loop is started;
  #  - if the remote file is missing, 
  #     - if the $OPA_INPUT_TIMEOUT__UTC is lasted, exits with an error code;
  #       otherwise, tries again to download
  #  - if the downloaded file cannot be decompressed, tries again to download;
  #  - if the checks on the downloaded and decompressed file fails,
  #       tries again to download
  typeset _a_f_d="$1"
  shift 1
  typeset _lfile _decompressed_lfile
  typeset _rfile _compressed_rfile 
  typeset _compress_mode
  typeset _download_mode
  typeset -i _ec
  typeset -i _errors=0
  typeset _now
  typeset _timeout=$(opa_date_day_offset "${OPA_RUNDATE} $OPA_INPUT_TIMEOUT__UTC" $OPA_SUBMIT_DAY_OFFSET "%Y%m%d %H:%M:%S")
  typeset _timeout_s=$( $OPA_BINDIR/date --utc --date="$_timeout" +%s)
  typeset _timeout_count_max=$_MAX_TRIES
  typeset _timeout_delay=$_DELAY
  typeset _file_found
  typeset _abort_on_errors=$_ABORT_ON_ERRORS
  set -A _input_lfiles
  set -A _input_rfiles
  set -A _input_compress_modes
  set -A _input_download_modes
  set -A _input_rdirs
  typeset _input_files_indices
  typeset -i _input_files_index
  echo "@@@ [${0}]: _a_f_d=[${_a_f_d}]"
  typeset _rdir		# remote directory
  typeset _lidir	# local input directory
  typeset _lwdir	# local working directory
  cat <<EOFCAT
timeout=[${_timeout}] [${_timeout_s}]
EOFCAT
  case "$_a_f_d" in
    a)
      _input_files_indices=$(opa_set_difference "${OPA_OPAOPER_A_INPUT_FILES_INDICES}" "$_DOWNLOADED_INDICES_A")
      for _input_files_index in $_input_files_indices ; do
        _input_lfiles[_input_files_index]="${OPA_OPAOPER_A_INPUT_LFILES[_input_files_index]}"
        _input_rfiles[_input_files_index]="${OPA_OPAOPER_A_INPUT_RFILES[_input_files_index]}"
        _input_compress_modes[_input_files_index]="${OPA_OPAOPER_A_INPUT_COMPRESS_MODES[_input_files_index]}"
        if $_EMERG ; then
	  _input_download_modes[_input_files_index]="${OPA_OPAOPER_A_INPUT_DOWNLOAD_MODES_EMERG[_input_files_index]}"
	else
          _input_download_modes[_input_files_index]="${OPA_OPAOPER_A_INPUT_DOWNLOAD_MODES[_input_files_index]}"
	fi
        _input_rdirs[_input_files_index]="${OPA_OPAOPER_A_INPUT_RDIRS[_input_files_index]}"
      done
      ;;
    f)
      _input_files_indices=$(opa_set_difference "${OPA_OPAOPER_F_INPUT_FILES_INDICES}" "$_DOWNLOADED_INDICES_F")
      for _input_files_index in $_input_files_indices ; do
        _input_lfiles[_input_files_index]="${OPA_OPAOPER_F_INPUT_LFILES[_input_files_index]}"
        _input_rfiles[_input_files_index]="${OPA_OPAOPER_F_INPUT_RFILES[_input_files_index]}"
        _input_compress_modes[_input_files_index]="${OPA_OPAOPER_F_INPUT_COMPRESS_MODES[_input_files_index]}"
	if $_EMERG ; then
          _input_download_modes[_input_files_index]="${OPA_OPAOPER_F_INPUT_DOWNLOAD_MODES_EMERG[_input_files_index]}"
	else
          _input_download_modes[_input_files_index]="${OPA_OPAOPER_F_INPUT_DOWNLOAD_MODES[_input_files_index]}"
	fi
        _input_rdirs[_input_files_index]="${OPA_OPAOPER_F_INPUT_RDIRS[_input_files_index]}"
      done
      ;;

  esac

  _lidir="$OPA_INPDIR/CMCC_PHYS"
  _lwdir="$OPA_WRKDIR/CMCC_PHYS"

  typeset _lidir_download="$_lidir/$(hostname).$$.$RANDOM"	# local directory for download
  trap "rm -rf ${_lidir_download:-undefined}" 0

  [[ -d $_lidir ]] || opa_mkdir $_lidir
  [[ -d $_lidir_download ]] || opa_mkdir $_lidir_download
  [[ -d $_lwdir ]] || opa_mkdir $_lwdir
  
  if $_DRY_RUN ; then
    echo "WRN: DRY RUN, download is disabled!"
    return 0
  fi

  typeset _timeout_count_exceeded
  typeset _timeout_exceeded
  for _input_files_index in $_input_files_indices ; do
    _lfile="${_input_lfiles[_input_files_index]}"
    _rfile="${_input_rfiles[_input_files_index]}"
    _compress_mode="${_input_compress_modes[_input_files_index]}"
    _download_mode="${_input_download_modes[_input_files_index]}"
    _rdir="${_input_rdirs[_input_files_index]}"
    _compressed_rfile="${_rfile}"
    _decompressed_lfile="${_lfile}"
    _file_found=false
    # check if file has already been downloaded:
    if [[ -f "$_lidir/$_compressed_rfile" ]] ; then
      echo "DEBUG: $_lidir/$_compressed_rfile esiste, _FORCE_DOWNLOAD=$_FORCE_DOWNLOAD"
      if $_FORCE_DOWNLOAD ; then
        echo "### file [${_compressed_rfile}] already exists, but FORCE_DOWNLOAD=true => try to download again"
      else
        echo "### file [${_compressed_rfile}] already exists, and FORCE_DOWNLOAD=false => try to resume download"
        opa_cp -p $_lidir/$_compressed_rfile $_lidir_download
        _file_found=true
      fi
    else
      echo "### file [${_compressed_rfile}] does not exist => try to download"
    fi

    # file download:
    typeset -i _timeout_count=0
    while true ; do
      if ! $_file_found ; then
        _timeout_count=$(( $_timeout_count + 1 ))
        if $_DISABLE_DOWNLOAD ; then
          echo "### [${_timeout_count}] trying to recover file '$_lidir/$_compressed_rfile'..."
          if [[ -f "$_lidir/$_compressed_rfile" ]] ; then
            opa_cp $_lidir/$_compressed_rfile $_lidir_download/$_compressed_rfile
          fi
        else

            echo "### [${_timeout_count}] trying to download '$_rdir/$_compressed_rfile'..."
            opa_download "$_download_mode" "$_lidir_download" "$_rdir/$_compressed_rfile" ; _ec=$?

        fi
        if [[ $_ec != 0 || ! -f "$_lidir_download/$_compressed_rfile" ]] ; then
          if [[ -f "$_lidir_download/$_compressed_rfile" ]] ; then
            opa_prex "rm -f $_lidir_download/$_compressed_rfile"
          fi
          # file not downloaded
          _now=$( $OPA_BINDIR/date --utc +'%Y%m%d %H:%M:%S' )
          _now_s=$( $OPA_BINDIR/date --utc --date="$_now" +'%s' )
          _timeout_count_exceeded=false
          if [[ $_timeout_count -gt $_timeout_count_max ]] ; then
            _timeout_count_exceeded=true
          fi
          _timeout_exceeded=false
          if [[ "$_now_s" -gt "$_timeout_s" ]] ; then
            _timeout_exceeded=true
          fi
          printf "###DBG: now=[%s (%s)], timeout=[%s (%s)], exceeded=[%s]; count=[%s/%s], exceeded=[%s]\n" "$_now" "$_now_s" "$_timeout" "$_timeout_s" "$_timeout_exceeded" "$_timeout_count" "$_timeout_count_max" "$_timeout_count_exceeded"
          if $_timeout_exceeded && $_timeout_count_exceeded ; then
            # AFTER timeout! exit from function
            opa_add_missing_files "$_rdir/$_compressed_rfile"
            _errors=$(( $_errors + 1 ))
            if $_abort_on_errors ; then
              opa_log 0 "INPUT TIMEOUT - missing file [${_compressed_rfile}] - aborting"
              return $_errors
            else
              opa_log 0 "INPUT TIMEOUT - missing file [${_compressed_rfile}] - file is skipped"
              break
            fi
          else
            # before timeout, continue to wait
            echo "### missing file [${_compressed_rfile}] - waiting"
            opa_wait "$_timeout_delay"
            continue
          fi
        else
          # file trovato
          _file_found=true
        fi 
      fi



      # file check:
      #   if chec fails, tries again to download forever;
      #   this is to prevent downloading incomplete or corrupted files
      if $_file_found ; then
        # some code to check if $_decompressed_lfile is correct
        if ! opa_check_input_file $_lidir_download/$_compressed_rfile ; then
          opa_log 1 "file [${_compressed_rfile}] : check failed!"
          _file_found=false
        fi
        opa_prex "mv    $_lidir_download/$_compressed_rfile $_lidir"
        # opa_cp -p $_lidir/$_compressed_rfile $_lwdir                      # cp orig in wrkdir/analysis/2/OPAOPER_A
        # opa_cp -p $_lidir/$_compressed_rfile $_lidir/$_decompressed_lfile # cp orig in inpdir/analysis/20200218/OPAOPER_A/20200209_T.nc
        # opa_cp -p $_lidir/$_decompressed_lfile $_lwdir                    # cp inpdir/analysis/20200218/OPAOPER_A/20200209_T.nc wrkdir/analysis/2/OPAOPER_A

        opa_prex_or_die "ln -fs $_lidir/$_compressed_rfile $_lwdir/$_decompressed_lfile "

      fi

      # exit from loop if file has been found
      if $_file_found ; then
        case "$_a_f_d" in
          a)
            _DOWNLOADED_INDICES_A="$_DOWNLOADED_INDICES_A$_input_files_index "
            ;;
          f)
            _DOWNLOADED_INDICES_F="$_DOWNLOADED_INDICES_F$_input_files_index "
            ;;
        esac
        break		# breaks the inner endless loop => try to download next file
      else
        opa_log 1 "file [${_decompressed_lfile}] not downloaded or corrupted - try again to download"
      fi
    done
  done
  unset _input_lfiles
  unset _input_rfiles
  return $_errors
}


function opa_get_atmospheric_files {
typeset _a_f_d="$1"

typeset _lidir="$OPA_INPDIR/ECMWF"
[[ -d $_lidir ]] || opa_mkdir $_lidir

case "$_a_f_d" in
a)
   for input_file_index in $(opa_range 0 8) ; do
       _rfile=${OPA_ATM_A_INPUT_RFILES[input_file_index]}
       opa_download ncftp:$_HTTPCONFIG_CMCC "$_lidir" "$OPA_ATM_RDIR/$_rfile" ; _ec=$?
   done
   ;;
s|f)
   for input_file_index in 0 1 ; do
     _rfile=${OPA_ATM_F_INPUT_RFILES[input_file_index]}
     opa_download ncftp:$_HTTPCONFIG_CMCC "$_lidir" "$OPA_ATM_RDIR/$_rfile" ; _ec=$?
   done
   ;;
esac
}


errors=0


#case $OPA_RUNTYPE in
#   'analysis' )
#      for i in $OPA_OPAOPER_A_INPUT_FILES_INDICES ; do
#        printf "### A[%03d] %30s ::: %30s -> %30s\n" "$i" "${OPA_OPAOPER_A_INPUT_RDIRS[i]}" "${OPA_OPAOPER_A_INPUT_RFILES[i]}" "${OPA_OPAOPER_A_INPUT_LFILES[i]}"
#      done
#      ;;
#    'forecast' )
#      for i in $OPA_OPAOPER_F_INPUT_FILES_INDICES ; do
#        printf "### F[%03d] %30s ::: %30s -> %30s\n" "$i" "${OPA_OPAOPER_F_INPUT_RDIRS[i]}" "${OPA_OPAOPER_F_INPUT_RFILES[i]}" "${OPA_OPAOPER_F_INPUT_LFILES[i]}"
#      done
#      ;;
#    * ) opa_die 10 "Unsupporte runtype: $OPA_RUNTYPE"
#esac

case $OPA_RUNTYPE in
    'analysis' ) opa_get_atmospheric_files 'a' || errors=$(( $errors + 1 )) ;;
    'forecast' ) opa_get_atmospheric_files 'f' || errors=$(( $errors + 1 )) ;;
    * ) opa_die 10 "Unsupporte runtype: $OPA_RUNTYPE"
esac


while true ; do
  errors=0
  case $OPA_RUNTYPE in
    'analysis' )  opa_get_files 'a' || errors=$(( $errors + 1 )) ;;
    'forecast' )  opa_get_files 'f' || errors=$(( $errors + 1 )) ;;
    * ) opa_die 10 "Unsupporte runtype: $OPA_RUNTYPE"
  esac

  opa_report "bio_transfer-tl-input_forcing" "$errors" "false"
  typeset -i f_errors=$errors


  if [[ $errors -gt 0 ]] && ( ! $_INPUT_TIMEOUT_ENABLED ) ; then
    opa_print_missing_files
    opa_log 1 "Found $errors errors, timeout is disabled - continuing download"
    continue
  else
    break
  fi
done

opa_print_missing_files
opa_report "bio_transfer-tl-input_available" "$errors" "false"

if [[ $OPA_RUNTYPE == 'analysis' ]] ; then

    ncconfig=$OPA_ETCDIR/nc-config/.mvr.ncconfig
    MVR_PRODUCTS=$OPA_WRKDIR/POSTPROC/AVE_FREQ_1/online_validation/MVR/ONLINE_TIMESERIES
    opa_mkdir $MVR_PRODUCTS
    opa_prex "$OPA_BINDIR/ncftpget -f $ncconfig $MVR_PRODUCTS /upload/CLASS4/MED/product_quality_stats_MEDSEA_ANALYSISFORECAST_BGC_006_014*"

fi

opa_exit "$errors"




