#!/usr/bin/env python

import os
import sys
import argparse

from partition import *

def main():
    def _type(s_type):
        for t_type in (int, float, long):
            if s_type == t_type.__name__:
                return t_type
        else:
            return None

    all_cache_flags = 'lansgpm'
    cache_flag_description = {
	'l':		'Reduce after last p = P - 1',
	'a':		'Reduce after every p',
	'n':		'Reduce never',
	's':		'Show cache statistics',
	'g':		'Show cache reduction data',
	'p':		'Show partition matrix',
	'm':		'Show measure matrix',
    }
    cache_flags_description = "[{0}]".format(', '.join("{0!r}: {1}".format(f, cache_flag_description[f]) for f in all_cache_flags))

    def cache_flags_type(c_flags):
        cache_flags = []
        invalid_flags = []
        for c in c_flags.lower():
            if c in all_cache_flags:
                if not c in cache_flags:
                    cache_flags.append(c)
            else:
                if not c in invalid_flags:
                    invalid_flags.append(c)
        if invalid_flags:
            raise argparse.ArgumentTypeError("Invalid cache flag {0!r}".format(''.join(invalid_flags)))

        return ''.join(cache_flags)

    parser = argparse.ArgumentParser(description='Find the balanced partition of an array')
    array_group = parser.add_mutually_exclusive_group(required=True)

    f_array_group = array_group.add_argument_group('Random array')
    #f_array_group = array_group
    array_group.add_argument(	'--input-filename', '-i',
				type=str,
				default=None,
				help='file containing the input array')

    r_array_group = array_group.add_argument_group('Random array')
    #r_array_group = array_group
    array_group.add_argument(	'--random', '-r',
				action="store_true",
				default=None,
				help='create a random array')

    r_array_group.add_argument(	'--random-min', '-m',
				type=float,
				default=0.0,
				help='min value for random array')

    r_array_group.add_argument(	'--random-max', '-M',
				type=float,
				default=100.0,
				help='min value for random array')

    r_array_group.add_argument(	'--random-num', '-N',
				type=int,
				default=100,
				help='number of elements in the random array')

    r_array_group.add_argument(	'--random-type', '-T',
				type=_type,
				default=None,
				help='type of the random array')

    r_array_group.add_argument(	'--random-seed', '-E',
				type=str,
				default=None,
				help='seed for random generator')

    parser.add_argument(	'--num-partitions', '-p',
				type=int,
				default=10,
				help='number of partitions')

    parser.add_argument(	'--output-array-filename',
				type=str,
				default=None,
				help='Output filename for array')

    parser.add_argument(	'--output-odd-filename',
				type=str,
				default=None,
				help='Output filename for result in ODD (Opa Domain Decomposition) format')

    parser.add_argument(	'--output-partition-filename',
				type=str,
				default=None,
				help='Output filename for result in partition')

    parser.add_argument(	'--output-root-filename', '-R',
				type=str,
				default=None,
				help='Output root filename')

    parser.add_argument(	'--load-db', '-l',
				dest='load_db',
				action="store_true",
				default=None,
				help='Load db (restart from db)')

    parser.add_argument(	'--do-not-load-db', '-L',
				dest='load_db',
				action="store_false",
				default=None,
				help='Do not load db (restart from scratch)')

    parser.add_argument(	'--dump-db', '-b',
				dest='dump_db',
				action="store_true",
				default=None,
				help='Dump db')

    parser.add_argument(	'--do-not-dump-db', '-B',
				dest='dump_db',
				action="store_false",
				default=None,
				help='Do not dump db')

    parser.add_argument(	'--db-path', '-d',
				type=str,
				default=None,
				help='Db path for partition')

    parser.add_argument(	'--algorithm', '-a',
				type=str, choices=PManager.ALGORITHMS,
				default=PManager.DEFAULT_ALGORITHM,
				help='Algorithm to be used [{0}]'.format(', '.join(PManager.ALGORITHMS)))

    parser.add_argument(	'--optimize', '-o',
				action="store_true",
				default=None,
				help='Do optimization')

    parser.add_argument(	'--increment', '-I',
				type=float,
				default=None,
				help='Add an increment to the array values')

    parser.add_argument(	'--threshold', '-t',
				type=float,
				default=None,
				help='Threshold to stop optimization')

    parser.add_argument(	'--stop-after', '-s',
				metavar='S',
				type=int,
				default=None,
				help='Stop after S dummy iterations')

    parser.add_argument(	'--max-cache-size', '-c',
				metavar='C',
				type=int,
				default=None,
				help='Max cache size')

    parser.add_argument(	'--cache-flags', '-x',
				metavar='X',
				type=cache_flags_type,
				default='',
				help='Cache management flags: {0}'.format(cache_flags_description))

    parser.add_argument(	'--depth', '-D',
				metavar='D',
				type=int,
				default=None,
				help='Max depth of recursive search of sub-partitions')
				
    parser.add_argument(	'--odd-filename', '-f',
				metavar='O',
				type=str,
				default=None,
				help="Filename for the result in ODD (Opa Domain Decomposition) format")

    parser.add_argument(	'--verbose-level', '-v',
				action="count",
				default=0,
				help='Increase verbose level')

    parser.add_argument(	'--verbose', '-V',
				dest="verbose_level",
				type=int,
				default=0,
				help='Set verbose output')

    parser.add_argument(	'--show-stats', '-S',
				action='store_true',
				default=False,
				help='Show statistics')

    parser.add_argument(	'--show-partition', '-P',
				action='store_true',
				default=False,
				help='Show partition')

    parser.add_argument(	'--parameter', '-w',
				dest="algorithm_parameters",
				action='append',
				default=[],
				help='Add parameter')

    args = parser.parse_args()

    if args.random_seed:
        random.seed(args.random_seed)

    if args.random:
        parray = PArray.random(args.random_num, min_value=args.random_min, max_value=args.random_max, value_type=args.random_type)
        default_load_db = False
    elif args.input_filename:
        parray = PArray.fromfile(args.input_filename)
        default_load_db = True

    if args.increment:
        parray = PArray(x + args.increment for x in parray)

    if args.optimize is None:
        if args.output_array_filename:
            args.optimize = False
        else:
            args.optimize = True

    if args.load_db is None:
        args.load_db = default_load_db
        
    if args.output_root_filename is None:
        if args.input_filename:
            f, e = os.path.splitext(args.input_filename)
            args.output_root_filename = '{0}-{1}'.format(f, args.num_partitions)

    if args.output_root_filename is not None:
        for key in ('array', 'odd', 'partition'):
            attribute_name = 'output_{0}_filename'.format(key)
            attribute_value = getattr(args, attribute_name)
            if attribute_value is None:
                setattr(args, attribute_name, '{0}.{1}'.format(args.output_root_filename, key))
    

    db_path = args.db_path
    if db_path is None:
        if args.output_root_filename is not None:
            root = args.output_root_filename
        else:
            root = None
        if root is not None:
            db_path = '{0}.{1}.db'.format(root, args.algorithm)
        

    pmanager = PManager( args.num_partitions,
			parray,
			load_db=args.load_db,
			dump_db=args.dump_db,
			db_path=db_path,
			verbose_level=args.verbose_level,
			)

    opt_parameters = {}
    opt_parameters.update(args.algorithm_parameters)
    for key in ('threshold', 'stop_after', 'depth', 'max_cache_size', 'cache_flags'):
        if getattr(args, key) is not None:
            opt_parameters[key] = getattr(args, key)

    if args.optimize:
        pmanager.optimize(args.algorithm, **opt_parameters)
        pmanager.print_fitness()
        if args.show_partition:
            pmanager.print_partition()
        if args.show_stats:
            print
            pmanager.print_stats()

    if args.output_array_filename:
        pmanager.dump_array(args.output_array_filename)
    if pmanager.best_partition:
        partition = pmanager.best_partition
        if args.output_odd_filename:
            odd = pmanager.partition2odd(partition)
            pmanager.dump_odd(args.output_odd_filename, odd)
        if args.output_partition_filename:
            pmanager.dump_partition(args.output_partition_filename, partition)
        
if __name__ == "__main__":
    main()


